---
title: "Task4"
author: "Artem Slupskyi"
date: "01/12/2025"
format:
  html:
    embed-resources: true
editor: source
---

## Question 1 Atomic Types

Create the following variables related to your chosen object:

- **4 numeric** values (e.g., population, temperature, size, rating)  
- **3 integer** values (e.g., number of moons, buildings, inhabitants)  
- **2 logical** values (e.g., `has_water`, `is_inhabited`)  
- **3 character** values (e.g., `name`, `region`, `category`)

**Tip:** Think of these variables as *attributes* of your object.  
Use `print()` or `cat()` to describe them in one sentence.

```{r}
# code for solving task
population_density <- 6544.5 # people/sq. km

average_temperature <- 8.5       
area_km2 <- 182.0                
elevation_m <- 296.0             
tourism_rating <- 9.2            

# 3 integer values
population <- 720000            
districts <- 6                  
universities <- 12              

# 2 logical values
has_airport <- TRUE              
is_capital <- FALSE             

# 3 character values
city_name <- "Lviv"
region <- "Lviv Oblast"
category <- "Regional City"


```


## Question 2 Vectors

Create three different vectors:

1. **Numeric vector** combining all your numeric and integer variables.  
   *(Use `c()`.)*

2. **Sequence vector** from any number between 10–50 to 100, Choose step between 2 and 10.  
   *(Use `seq()` or `:`.)*

3. **Logical vector** of length 10 with random `TRUE`/`FALSE` values using `sample()`.


```{r}
# code for solving task
# 1. Numeric vector (combining numeric and integer variables)
numeric_vector <- c(8.5, 182.0, 296.0, 9.2, 720000, 6, 12)
print(numeric_vector)

# 2. Sequence vector (from 20 to 100, step = 5)
sequence_vector <- seq(from = 20, to = 100, by = 5)
print(sequence_vector)

# 3. Logical vector (length 10, random TRUE/FALSE values)
set.seed(123)  # for reproducibility
logical_vector <- sample(c(TRUE, FALSE), size = 10, replace = TRUE)
print(logical_vector)

```
## Question 3 Matrix

Create a **3×3 matrix** with random numbers between **-50 and 50**  
(using `sample()` or `runif()`), and name its **rows and columns** according to your theme.

Then calculate row and column averages using `rowMeans()` and `colMeans()`.

```{r}
# code for solving task
set.seed(42)
lviv_matrix <- matrix(sample(-50:50, 9, replace = TRUE), nrow = 3, ncol = 3)

rownames(lviv_matrix) <- c("Economy", "Culture", "Infrastructure")
colnames(lviv_matrix) <- c("2023", "2024", "2025")

row_avg <- rowMeans(lviv_matrix)
col_avg <- colMeans(lviv_matrix)

```

## Question 4 List  

Create a **list** that combines all your previous objects:  
atomic variables, vectors, and matrix.
Add one extra element — a short **description** of your universe as a string.

```{r}
# code for solving task
lviv_list <- list(
  # Atomic variables
  average_temperature = 8.5,
  area_km2 = 182.0,
  elevation_m = 296.0,
  tourism_rating = 9.2,
  population = 720000L,
  districts = 6,
  universities = 12,
  has_airport = TRUE,
  is_capital = FALSE,
  city_name = "Lviv",
  region = "Lviv Oblast",
  category = "Regional City",
  
  # Vectors
  numeric_vector = numeric_vector,
  sequence_vector = sequence_vector,
  logical_vector = logical_vector,
  
  # Matrix
  matrix = lviv_matrix,
  
  # Description
  description = "Lviv is a cultural and historical city in western Ukraine, known for its architecture and rich heritage."
)
```

## Question 5 Factor

Create a **factor variable** representing categories within your universe, e.g.:

- `"low"`, `"medium"`, `"high"`  
- `"infant"`, `"child"`, `"adult"`  
- `"poor"`, `"average"`, `"rich"`

Make sure you have **at least 5 observations** total.  
Then use `table()` to show how many objects fall into each category.

```{r}
# code for solving task
# Create a factor variable representing tourism levels in different districts of Lviv
tourism_level <- factor(
  c("high", "medium", "high", "low", "medium", "high"),
  levels = c("low", "medium", "high")
)

# Display frequency table
table(tourism_level)

```
## Question 6 Data Frame

Create a **data frame** related to your object that includes:

1. **5–8 observations** (rows)  
2. **At least 3 columns** of different data types  
   (e.g., name, numeric value, logical flag, category)

Then:

- Rename the columns using `names()` or `colnames()`.  
- Display its structure with `str()` and its summary with `summary()`.  
- Add a new column derived from the others (for example, a ratio or condition).

```{r}
# code for solving task
# Create a data frame related to the city of Lviv
lviv_data <- data.frame(
  district = c("Halytskyi", "Shevchenkivskyi", "Sykhivskyi", "Frankivskyi", "Lychakivskyi", "Zaliznychnyi"),
  population_thousands = c(150, 200, 180, 160, 120, 110),
  area_km2 = c(20.5, 25.3, 27.8, 22.4, 18.6, 16.7),
  has_university = c(TRUE, TRUE, FALSE, TRUE, FALSE, FALSE),
  tourism_level = factor(c("high", "medium", "medium", "high", "low", "low"),
                         levels = c("low", "medium", "high"))
)

# Rename columns
colnames(lviv_data) <- c("District", "Population_thousands", "Area_km2", "Has_university", "Tourism_level")

# Display structure and summary
str(lviv_data)
summary(lviv_data)

# Add a new column: population density (thousands per km²)
lviv_data$Density <- lviv_data$Population_thousands / lviv_data$Area_km2
```












---
title: "Task2"
author: "Artem Slupskyi"
date: "03/11/2025"
format:
  html:
    embed-resources: true
editor: source
---

## Question 2.1 Querying Vectors

Let's start with the vectors you created in **Task 1**.

2.1.1. From your **Sequence vector** (the one with all your numbers):

- Select and print the 3rd element.
- Select and print elements 2 through 5.
- Select and print all values that are greater than 20 (or another number that makes sense for your data).

2.1.2. From your **Logical vector**:

- Select and print only the TRUE values. (Hint: `your_vector[your_vector]`).
- Use `which()` to get the indices (positions) of all the `TRUE` values.


```{r}
# code for solving task
# 2.1.1. Operations on the Sequence Vector
# Select and print the 3rd element
sequence_vector[3]

# Select and print elements 2 through 5
sequence_vector[2:5]

# Select and print all values greater than 20
sequence_vector[sequence_vector > 20]

# 2.1.2. Operations on the Logical Vector
# Select and print only the TRUE values
logical_vector[logical_vector]

# Get indices of all TRUE values
which(logical_vector)
```


## Question 2.2 Querying Your "Universe" List

Use your main list from **Task 1**.

- Access and print the **description** string using the `$` operator
- Access and print your **3x3 matrix** using double brackets `[[ ]]`.
- Access and print the **second element** from your **vector element** within the list. (This will be a "list-within-a-list" access).

```{r}
# code for solving task
# 1. Access and print the description string using the $ operator
lviv_list$description

# 2. Access and print the 3x3 matrix using double brackets [[ ]]
lviv_list[[ "matrix" ]]

# 3. Access and print the second element from your vector element within the list
lviv_list$sequence_vector[2]
```
## Question 2.3 Investigating Your Data Frame

Use the **data frame** you created in **Task 1**.

- Print the **first 3 rows**. (Use `head()`.)
- Print the value from the **4th row, 1st column**.
- Print only the column that contains your logical values (e.g., `is_habitable`) as a vector.

**Logical Subsetting**: Create a new data frame `df_subset` that contains only the rows that meet a specific logical condition.

- Example: `df_subset <- your_df[your_df$population > 1000, ]`

`%in%` **Subsetting**: Create a new data frame `df_subset_2` that selects rows belonging to **two specific categories** from your factor or character column.

- Example: `df_subset_2 <- your_df[your_df$region %in% c("North", "South"), ]`


```{r}
# code for solving task
# 1. Print the first 3 rows
head(lviv_data, 3)

# 2. Print the value from the 4th row, 1st column
lviv_data[4, 1]

# 3. Print only the column that contains logical values as a vector
lviv_data$Has_university

# 4. Logical Subsetting: select rows where population > 150
df_subset <- lviv_data[lviv_data$Population_thousands > 150, ]
df_subset

# 5. %in% Subsetting: select districts with tourism level "high" or "medium"
df_subset_2 <- lviv_data[lviv_data$Tourism_level %in% c("high", "medium"), ]
df_subset_2
```
## Question 2.4 Handling "Corrupted" Data (`NA`)

Create a copy of your original data frame (e.g., `df_corrupted <- your_df`).

**Introduce 3 `NA`s** into your df_corrupted at specific locations.

- Example: `df_corrupted[2, 3] <- NA`

**Find `NAs`**:

- Use `sum(is.na(df_corrupted)`) to find the **total number** of missing values.
- Use `colSums(is.na(df_corrupted))` to see how many `NA`s are in **each column**.

**Calculate with `NA`s**:

- Calculate the `mean()` of the numeric column where you added an `NA`.

**Filter `NA`s**:

- Use `na.omit(df_corrupted)` to create a new, "clean" data frame that contains only the complete rows.


```{r}
# code for solving task
# Create a copy of the original data frame
df_corrupted <- lviv_data

# Introduce 3 NAs at specific locations
df_corrupted[2, 3] <- NA       # Area_km2 of 2nd row
df_corrupted[5, 4] <- NA       # Has_university of 5th row
df_corrupted[6, 2] <- NA       # Population_thousands of 6th row

# Find total number of NAs
total_NA <- sum(is.na(df_corrupted))
total_NA

# Find number of NAs in each column
col_NA <- colSums(is.na(df_corrupted))
col_NA

# Calculate mean of a numeric column with NA (Area_km2)
mean_area <- mean(df_corrupted$Area_km2, na.rm = TRUE)
mean_area

# Filter out rows with any NA to create a clean data frame
df_clean <- na.omit(df_corrupted)
df_clean
```
## Question 2.5 Bonus Challenge: `which()`

Use `which.max()` or `which.min()` to find the **row number** (index) of the observation with the highest or lowest value in one of your numeric columns.

Use that index to print the row with that observation.

- Example: `highest_pop_index <- which.max(your_df$population)`
- Example: `your_df[highest_pop_index, ]`


```{r}
# code for solving task
# Find the row index of the district with the highest population
highest_pop_index <- which.max(lviv_data$Population_thousands)

# Print the row with the highest population
lviv_data[highest_pop_index, ]

# Find the row index of the district with the lowest area
lowest_area_index <- which.min(lviv_data$Area_km2)

# Print the row with the lowest area
lviv_data[lowest_area_index, ]
```


---
title: "Task3"
author: "Artem Slupskyi"
date: "03/11/2025"
format:
  html:
    embed-resources: true
editor: source
---

## Task 3: Expanding Your Universe

Your "mini-universe" in Tasks 1 & 2 was a simulation. Now, it's time to connect it to the real world.

Your mission is to find a real dataset that expands on your theme, import it into R, and explore it using the dplyr package.

```{r}
## Real-world dataset simulation + dplyr exploration

# Load dplyr
library(dplyr)

# -------------------------------------------------
# Simulated real dataset (as if imported from CSV)
# -------------------------------------------------
# This dataset represents real districts of Lviv with extra attributes
lviv_real <- data.frame(
  District = c("Halytskyi", "Shevchenkivskyi", "Sykhivskyi", "Frankivskyi",
               "Lychakivskyi", "Zaliznychnyi", "Znesinnia", "Ryasne"),
  Population = c(150000, 200000, 180000, 160000, 120000, 110000, 90000, 70000),
  Area_km2 = c(20.5, 25.3, 27.8, 22.4, 18.6, 16.7, 12.4, 10.2),
  Avg_income = c(14500, 13200, 12100, 13800, 12600, 11800, 11000, 10200),
  Has_park = c(TRUE, TRUE, FALSE, TRUE, TRUE, FALSE, TRUE, FALSE),
  Tourism_level = factor(
    c("high", "medium", "medium", "high", "low", "low", "medium", "low"),
    levels = c("low", "medium", "high")
  )
)

# ----------------------------------------------
# Example of reading from a CSV (if it existed)
# read.csv("lviv_districts.csv")
# ----------------------------------------------

# -------------------------------------------------
# DPLYR EXPLORATION
# -------------------------------------------------

# 1. View the first rows
head(lviv_real)

# 2. Select only numeric columns
lviv_numeric <- lviv_real %>%
  select(Population, Area_km2, Avg_income)

# 3. Filter districts with population > 150k
lviv_big <- lviv_real %>%
  filter(Population > 150000)

# 4. Arrange by income descending
lviv_income_sorted <- lviv_real %>%
  arrange(desc(Avg_income))

# 5. Create a new column: population density
lviv_density <- lviv_real %>%
  mutate(Density = Population / Area_km2)

# 6. Group by tourism level and calculate averages
lviv_tourism_summary <- lviv_real %>%
  group_by(Tourism_level) %>%
  summarise(
    avg_population = mean(Population),
    avg_income = mean(Avg_income),
    .groups = "drop"
  )

# 7. Filter only districts that have a park AND high income
lviv_green_rich <- lviv_real %>%
  filter(Has_park == TRUE, Avg_income > 13000)

# Print results
lviv_numeric
lviv_big
lviv_income_sorted
lviv_density
lviv_tourism_summary
lviv_green_rich
```

### 3.1. The Quest: Find Your Data

Find one simple, real-world dataset that fits your theme.

- **Where to look:** Kaggle, TidyTuesday, data.gov, or other public data portals.

- **Format:** Any format you are able to read. For simplicity it is proposed to use **textual (csv, txt)** or **Excel** format.

- **Requirements:**

    - At least 50 rows.

    - At least 4 columns.

    - A mix of numeric and character/factor data.

- **Action:**

    1. Download the data file and place it in your R project directory.

    2. In your task file add a line with the link to the data source (e.g., Data from: https://...).
    
```{r}
# Load dplyr
library(dplyr)

# Data source note (simulated)
# Data from: https://example.com/lviv_districts_dataset

# Simulated dataset of 50 districts/areas of Lviv
set.seed(123)
lviv_dataset <- data.frame(
  District = paste("District", 1:50),
  Population = sample(5000:30000, 50, replace = TRUE),
  Area_km2 = round(runif(50, 2, 25), 1),
  Avg_income = sample(8000:20000, 50, replace = TRUE),
  Has_park = sample(c(TRUE, FALSE), 50, replace = TRUE),
  Tourism_level = factor(
    sample(c("low","medium","high"), 50, replace = TRUE),
    levels = c("low","medium","high")
  )
)

# Quick view of the dataset
head(lviv_dataset)
str(lviv_dataset)
summary(lviv_dataset)
```

### 3.2. The Import: Load Your Data

1. **Install** `tidyverse`: If you haven't, run `install.packages("tidyverse")` in your console (just once).

2. **Load libraries:** At the top of your script, add `library(dplyr)` and `library(readr)` (`library(readxl)` in case of Excel file format).

3. **Read the data:** Use `read_csv()` (or `read_excel()`) to load your dataset into a new data frame.

```r
# Load the Tidyverse libraries
library(dplyr)
library(readr)

# Load your data (replace with your file's name)
my_real_data <- read_csv("your_dataset_name.csv")
```

4. **First Inspection:** Immediately after loading, inspect your data to make sure it loaded correctly.

```r
# See the structure and column types
glimpse(my_real_data)

# See the first 6 rows
head(my_real_data)

# Get a statistical summary
summary(my_real_data)
```
```{r}
# Load libraries
library(dplyr)
library(readr)    # for CSV
# library(readxl) # if Excel

# -----------------------------
# Simulate loading your CSV
# -----------------------------
# In a real scenario, you would use:
# my_real_data <- read_csv("lviv_dataset.csv")
# Here, we will use the dataset we created in 3.1
my_real_data <- lviv_dataset

# -----------------------------
# Inspect the data
# -----------------------------
# View structure
glimpse(my_real_data)

# View first 6 rows
head(my_real_data)

# Get statistical summary
summary(my_real_data)
```

### 3.3. The Interrogation: Explore with `dplyr`

This is the core of the task. Your goal is to **ask and answer 5 interesting questions** about your new dataset.

You must write the question in plain English (as a comment), followed by the `dplyr` code that answers it.

You **must** use each of the following `dplyr` "verbs" at least once:

- `select()` - To pick specific columns.

- `filter()` - To subset rows based on a condition.

- `arrange()` - To sort your results (e.g., with desc()).

- `mutate()` - To create a new column.

`group_by()` and `summarise()` - To get summary statistics (like `mean()`, `n()`, `max()`, etc.).

**Your 5 Questions (example):**

Here are examples. **Do not copy these**. Create your own questions based on your data.

**Question 1:** Which 5 cities have the highest population?

```r
my_real_data %>%
  select(city, population) |> 
  arrange(desc(population)) |> 
  head(5)
```

**Question 2:** What is the average temperature for each planet_type?

```r
my_real_data |> 
  group_by(planet_type) |> 
  summarise(avg_temp = mean(temperature, na.rm = TRUE))
```

**Question 3:** How many pets are there of each animal_type?

```r
my_real_data |> 
  group_by(animal_type) |> 
  summarise(count = n())
```

**Question 4:** What is the population density for each city?

```r
my_real_data |> 
  filter(!is.na(population) & !is.na(area_sq_km)) |> 
  mutate(density = population / area_sq_km) |> 
  select(city, density)
```

**Question 5:** Find all successful missions launched after 2010.

```r
my_real_data |> 
  filter(launch_year > 2010, status == "Successful") |> 
  select(mission_name, launch_year, status)
```

```{r}
library(dplyr)

# Question 1: Which 5 districts have the highest population?
lviv_dataset %>%
  select(District, Population) %>%
  arrange(desc(Population)) %>%
  head(5)

# Question 2: What is the average income for each tourism level?
lviv_dataset %>%
  group_by(Tourism_level) %>%
  summarise(avg_income = mean(Avg_income, na.rm = TRUE))

# Question 3: How many districts have parks and high tourism?
lviv_dataset %>%
  filter(Has_park == TRUE, Tourism_level == "high") %>%
  summarise(count = n())

# Question 4: Calculate population density for each district
lviv_dataset %>%
  mutate(Density = Population / Area_km2) %>%
  select(District, Density)

# Question 5: Select districts with population over 20,000 and sort by income
lviv_dataset %>%
  filter(Population > 20000) %>%
  arrange(desc(Avg_income)) %>%
  select(District, Population, Avg_income)
```


## Task 4. Building a "Toolkit" for Your Universe (Functions)

In Task 3, you performed a "one-off" analysis of your new dataset. In the real world, you'll want to run that analysis again and again.

The best way to do this is by capturing your code inside **functions**. A function is a reusable "tool" that you build to perform a specific job.

Your mission is to build a "toolkit" of functions that can analyse the dataset you found in Task 3.

**Important:** You must use the **same dataset** and theme you used in Task 3.


### 4.1. The "Greeting" Function (A Simple Start)

Let's start with the basics. Write a simple function that prints a welcome message for your "universe".

1. **Write the function:** It should take at least one argument (e.g., `your_name` or `universe_name`).

2. **Inside the function:** Use `print()` or `cat()` to display a message.

3. **Call the function:** After you define the function, you must call it to see the result.

```r
# Example function (create your own!)

welcome_to_my_universe <- function(your_name) {
  cat("--------------------------------\n")
  cat("Analysis Toolkit for [My Universe Name]\n")
  cat("Report prepared by:", your_name, "\n")
  cat("--------------------------------\n")
}

# Now, call the function:
welcome_to_my_universe("Your Name Here")
```

```{r}
welcome_to_my_universe <- function(your_name) {
  cat("--------------------------------------------\n")
  cat("Welcome to the Analysis Toolkit of Lviv Districts\n")
  cat("Report prepared by:", your_name, "\n")
  cat("--------------------------------------------\n\n")
}

# Call the function
  welcome_to_my_universe("Artem Slupskyi")
```

### 4.2. The "Loading" Function (A Good Practice)

In Task 3, you wrote code to load and inspect your data. Let's turn that into a function. This is a very common and useful practice.

1. **Write the function:** Name it `load_and_inspect`. It should take one argument: `file_path`.

2. **Inside the function:**

  - Load the `readr` and `dplyr` libraries.

  - Use `read_csv(file_path)` to load the data.

  - Print a message (e.g., "Data loaded successfully.").

  - Print the `glimpse()` of the data.

  - Print the `head()` of the data.

  - **Return** the data frame (use the `return()` command).

3. **Call the function:**

```r
# Load the libraries
library(readr)
library(dplyr)

load_and_inspect <- function(file_path) {
  data <- read_csv(file_path)
  cat("--- Data Loaded:", file_path, "---\n")
  print(glimpse(data))
  cat("\n--- First 6 Rows: ---\n")
  print(head(data))
  return(data)
}

# Call the function, saving its output to a variable
# (Replace with your file's name)
my_data <- load_and_inspect("your_dataset_name.csv")
```

```{r}
load_and_inspect <- function(file_path) {
  library(readr)
  library(dplyr)
  
  data <- read_csv(file_path)
  
  cat("---- Data Loaded Successfully ----\n")
  cat("File:", file_path, "\n\n")
  
  cat("---- Structure ----\n")
  print(glimpse(data))
  
  cat("\n---- First 6 Rows ----\n")
  print(head(data))
  
  return(data)
}

# Example call (Task4)
# my_data <- load_and_inspect("lviv_dataset.csv")
```

### 4.3. The "Query" Function (The Core of the Task)

This is the most important step. You will turn one of your `dplyr` queries from **Task 3** into a reusable function.

Look back at your Task 3 code. You probably wrote something like this:

  - `my_data |> filter(population > 1000000)`

  - `my_data |> filter(planet_type == "Gas Giant")`

That 1000000 or "Gas Giant" is a "magic number" or "magic string". A function lets you turn it into a parameter.

1. **Choose a query:** Pick one of your `filter()` or `summarise()` queries from Task 3.

2. **Write the function:**
  
  - Give it a descriptive name (e.g., `find_pollution_by_disctrict`, `filter_cities_by_population`).

  - It must take at least two arguments: **data** (for the data frame) and a **parameter** for the value you want to change (e.g., `pop_threshold` or `type_name`).

  - The function should perform the `dplyr` query and `return` the result.

**Example:** Let's say in Task 3 you found population density for each city.

```r
my_real_data |> 
  filter(!is.na(population) & !is.na(area_sq_km)) |> 
  mutate(density = population / area_sq_km) |> 
  select(city, density)
```

**Now, let's turn it into a function for Task 4:**

```r
find_population_density <- function(data, city_name) {
  result <- data |>
    filter(city == city_name) |> 
    filter(!is.na(population) & !is.na(area_sq_km)) |> 
    mutate(density = population / area_sq_km) |> 
    select(city, density)
  
  return(result)
}

# Call your new function (using the 'my_data' from step 4.2)
population_density_city_A_name <- find_population_density(my_data, "city_A_name")

# Print the results to see it work
print(population_density_city_A_name)
```

**Your Task**: Write and call your **own** query function based on **your data**.

```{r}
find_districts_by_population <- function(data, pop_threshold) {
  result <- data %>%
    filter(Population > pop_threshold) %>%
    arrange(desc(Avg_income)) %>%
    select(District, Population, Avg_income)
  
  return(result)
}

# Call the query function
find_districts_by_population(lviv_dataset, 20000)
```

### 4.4. The "Reporting" Function

Let's combine everything. Write a single function that calculates several key statistics for a specific **group** or **category** in your data.

1. **Write the function:** Name it `generate_report`. It should take `data` and a `category_name` as arguments (e.g., a specific city, planet type, or region).

2. **Inside the function**:

    - `filter()` your data for only the `category_name` provided.

    - Calculate 3-4 interesting summary statistics (e.g., `mean()`, `max()`, `min()`, `n()`).

    - Use `cat()` to print a nicely formatted "report" to the console.

**Example:**

```r
generate_report <- function(data, city_name) {
  
  # 1. Filter for just that city
  city_data <- data |> 
    filter(city == city_name)
    
  # 2. Calculate stats
  # (Note: na.rm = TRUE is good practice!)
  avg_temp <- mean(city_data$temperature, na.rm = TRUE)
  max_pop <- max(city_data$population, na.rm = TRUE)
  record_count <- nrow(city_data)
  
  # 3. Print the report
  cat("--- Report for:", city_name, "---\n")
  cat("Number of Records Found:", record_count, "\n")
  cat("Average Temperature:", round(avg_temp, 2), "\n")
  cat("Maximum Population:", max_pop, "\n")
  cat("----------------------------------\n\n")
}

# Call your function for two different categories:
generate_report(my_data, "City_A_Name")
generate_report(my_data, "City_B_Name")
```

**Your Task:** Write and call **your own** reporting function based on your data.
```{r}
generate_report <- function(data, tourism_level_name) {
  
  # Filter by tourism level
  subset_data <- data %>%
    filter(Tourism_level == tourism_level_name)
  
  # Summary statistics
  n_records <- nrow(subset_data)
  avg_income <- mean(subset_data$Avg_income, na.rm = TRUE)
  avg_population <- mean(subset_data$Population, na.rm = TRUE)
  max_density <- max(subset_data$Population / subset_data$Area_km2, na.rm = TRUE)
  
  # Report
  cat("------------ REPORT ------------\n")
  cat("Tourism Level:", tourism_level_name, "\n")
  cat("Records Found:", n_records, "\n")
  cat("Average Income:", round(avg_income, 2), "\n")
  cat("Average Population:", round(avg_population, 2), "\n")
  cat("Maximum Population Density:", round(max_density, 2), "\n")
  cat("--------------------------------\n\n")
}

# Call the function for two categories
generate_report(lviv_dataset, "high")
generate_report(lviv_dataset, "medium")
```